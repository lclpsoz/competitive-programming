#include <bits/stdc++.h>
using namespace std;

////////////// Prewritten code follows. Look down for solution. ////////////////
#define x first
#define y second
#define len(x) ((int)(x).size())
using pii = pair<int, int>;
using ll = long long;
using llu = long long unsigned;
using ld = long double;

const ld EPS = 1e-9;
inline int cmp(ld x, ld y = 0, ld tol = EPS) {
  return (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;
}

const int MOD = 1;
inline int mod (ll x, int m = MOD) {
  return (int)(((x%m) + m)%m);
}

////////////////////////// Solution starts below. //////////////////////////////

const int N = 1010;

int t;
int mat[N][N], mat_qnt[N][N];;
int bit[N];
queue<pii> q;

void add (int p, int v) {
  while (p < N) {
    bit[p] += v;
    p += p&-p;
  }
}

int sum (int p) {
  int r = 0;
  while (p >= 1) {
    r += bit[p];
    p -= p&-p;
  }
  
  return r;
}

// v are the values that
// remain
void clean_bit (int v = 0) {
  // printf ("CLEANING!\n");
  if (!q.empty()) {
    queue<pii> aux;
    int qnt = 0;
    while (!q.empty()) {
      if (q.front().x < v)
	aux.push (q.front());
      else if (q.front().x == v)
	++qnt;
      else {
	++qnt;
	add (1, -q.front().x);
	add (q.front().x+1, q.front().x);
      }
      q.pop();
    }

    if (v && qnt) {
      aux.push ({v, qnt});
      add (1, v*qnt);
      add (v+1, -(v*qnt));
      q = aux;
    }
  }
  // printf ("DONE!\n");
}

int main () {
  int r, c;
  scanf ("%d", &t);
  while (t--) {
    scanf ("%d %d", &r, &c);
    for (int i = 1; i <= r; i++)
      for (int j = 1; j <= c; j++) {
	scanf ("%d", &mat[i][j]);
	if (mat[i-1][j] == mat[i][j])
	  mat_qnt[i][j] = mat_qnt[i-1][j]+1;
	else
	  mat_qnt[i][j] = 1;
      }

    //printf ("--\n");
    ll ans = 0;
    for (int i = 1; i <= r; i++) {
      clean_bit();
      for (int j = 1; j <= c; j++) {
	if (mat[i][j] != mat[i][j-1])
	  clean_bit();
	else if (mat_qnt[i][j] < mat_qnt[i][j-1])
	  clean_bit(mat_qnt[i][j]);
	ans += mat_qnt[i][j];
	ans += (sum (1) - sum (mat_qnt[i][j]+1));
	//printf ("%d ", sum(1));
	//printf ("  |%d %d\n", sum (1), sum (mat_qnt[i][j]+1));
	add (1, mat_qnt[i][j]);
	add (mat_qnt[i][j]+1, -mat_qnt[i][j]);
	q.push ({mat_qnt[i][j], 1});
	//printf ("%d %d [%d] %lld\n", i, j, mat_qnt[i][j], ans);
      }
      //putchar ('\n');
    }
    clean_bit();
    printf ("%lld\n", ans);
  }
  
  return 0;
}
